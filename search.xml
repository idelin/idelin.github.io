<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>AiLPHA REST API指南</title>
    <url>/2022/03/26/AiLPHA-REST-API%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h2><p>AiLPHA REST API指南作为一种设计规范，鼓励开发同学通过RESTful HTTP接口访问资源。</p>
<p>本文档建立了AiLPHA REST API应该遵循的指导原则，以便开发统一一致的RESTful接口。</p>
<h2 id="2-引言"><a href="#2-引言" class="headerlink" title="2. 引言"></a>2. 引言</h2><p>为了给开发同学提供更流畅的开发体验，让API遵循统一的设计准则很重要，这些准则能让API简单且直观。</p>
<p>API一致性的好处在于使团队拥有统一的代码、模式、文档风格和设计策略。</p>
<p>这些准则旨在达成如下目标：</p>
<ul>
<li>尽可能地遵循行业普遍接受的 REST&#x2F;HTTP 最佳实践；</li>
<li>内部接口层面，让前后端对接更为顺畅；</li>
<li>对外接口层面，让第三方开发同学都可以轻松的通过REST接口访问的AiLPHA OPEN API；</li>
<li>接口测试层面，让测试同学可以按照标准更容易地去进行自动化接口测试；</li>
<li>让其他部门、合作伙伴使用这些准则来设计自己的REST API。</li>
</ul>
<h3 id="2-1-推荐阅读"><a href="#2-1-推荐阅读" class="headerlink" title="2.1 推荐阅读"></a>2.1 推荐阅读</h3><p>了解REST架构风格背后的理念，更有助于开发优秀的基于 HTTP 的服务。 如果您对 RESTful 设计不熟悉，请参阅以下优秀资源：</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7231">RFC7231</a> – 定义HTTP&#x2F;1.1 语义规范的权威文档</li>
<li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">REST论文</a> – Roy Fielding网络架构论文中关于REST的章节，“架构风格与基于网络的软件体系结构设计”</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a> – 一篇介绍RESTful架构较为准确的文章</li>
<li><a href="https://www.zhihu.com/question/27785028">生动理解REST</a> – 一篇介绍REST较为生动易懂的文章</li>
<li><a href="https://github.com/Microsoft/api-guidelines/blob/vNext/Guidelines.md#1444-example-response">微软API规范</a> – 本指南的主要参考规范</li>
</ul>
<h2 id="3-指南解读"><a href="#3-指南解读" class="headerlink" title="3. 指南解读"></a>3. 指南解读</h2><h3 id="3-1-应用指南"><a href="#3-1-应用指南" class="headerlink" title="3.1 应用指南"></a>3.1 应用指南</h3><p>这些准则适用于AiLPHA基础研发部（或任何公司内其他部门、公司外合作伙伴）开发服务里的公开REST API。私有或内部API也应该尝试遵循这些准则，保证一致性不仅对外部用户有价值，对内部服务使用者也很有价值，而这些准则为任何服务都提供了最佳实践。 </p>
<p>有合理理由可不遵循这些准则，如：</p>
<p>一些服务与某些外部定义的REST API互操作时必须与某些外部的API兼容，允许其无法遵循这些准则。</p>
<p>一些服务可能具有需要特殊功能上或性能上的需求，允许其无法遵循这些准则。</p>
<h3 id="3-2-历史接口"><a href="#3-2-历史接口" class="headerlink" title="3.2 历史接口"></a>3.2 历史接口</h3><p>不建议仅仅为了遵从指南而对这些指南之前的旧服务或模块进行重大更改。</p>
<h3 id="3-3-“要求”关键字"><a href="#3-3-“要求”关键字" class="headerlink" title="3.3 “要求”关键字"></a>3.3 “要求”关键字</h3><p>本文档中的 ”必须”（MUST、REQUIRED、SHALL）、”禁止”（MUST NOT、SHALL NOT）、”推荐”（SHOULD、RECOMMENDED）、 ”可以”（MAY）、”可选“（OPTIONAL） 等关键字的详细解释见 <a href="https://tools.ietf.org/html/rfc2119">RFC2119</a>。</p>
<h2 id="4-分类"><a href="#4-分类" class="headerlink" title="4. 分类"></a>4. 分类</h2><p>服务必须符合下面定义的分类法。</p>
<h3 id="4-1-错误（Error）"><a href="#4-1-错误（Error）" class="headerlink" title="4.1 错误（Error）"></a>4.1 错误（Error）</h3><p>错误，定义为因客户端向服务传递错误数据，导致服务端拒绝该请求。客户端传递错误的或者不合法的数据的情况通常返回 “4xx” 的 HTTP错误码。</p>
<p>错误不会影响API的整体可用性。</p>
<p>例如 无效凭证、错误的参数、未知的版本ID等。</p>
<h3 id="4-2-故障（Faults）"><a href="#4-2-故障（Faults）" class="headerlink" title="4.2 故障（Faults）"></a>4.2 故障（Faults）</h3><p>故障，定义为服务无法正确返回数据以响应有效的客户端请求。通常会返回“5xx”HTTP错误码。</p>
<p>故障会影响整体 API 的可用性。故障意味着服务端代码出现故障，可能会影响整体的API使用。</p>
<p>例如 数据库连接超时。</p>
<h2 id="5-客户端要求"><a href="#5-客户端要求" class="headerlink" title="5. 客户端要求"></a>5. 客户端要求</h2><p>为确保客户端更好的接入REST服务，客户端应遵循以下最佳实践:</p>
<h3 id="5-1-字段忽略原则"><a href="#5-1-字段忽略原则" class="headerlink" title="5.1 字段忽略原则"></a>5.1 字段忽略原则</h3><p>客户端<strong>必须</strong>安全地忽略未约定的字段。</p>
<p>在产品迭代的过程中，有些服务接口可能在不更改版本号的情况下向响应数据中添加字段。此类服务接口<strong>必须</strong>在其文档中注明，而客户端<strong>必须</strong>可以忽略这些未知字段。</p>
<h3 id="5-2-字段排序忽略原则"><a href="#5-2-字段排序忽略原则" class="headerlink" title="5.2 字段排序忽略原则"></a>5.2 字段排序忽略原则</h3><p>客户端处理响应数据时<strong>禁止</strong>依赖服务端JSON响应数据字段的顺序。</p>
<p>当服务器返回的 JSON 对象中的字段顺序发生变化，客户端应当能够正确进行解析处理。</p>
<p>服务端<strong>可以</strong>在返回值中显式说明指定某些元素按特定方式进行排序，客户端处理数据时<strong>可以</strong>依赖于服务端明确指定的排序行为。</p>
<h3 id="5-3-无声失效原则"><a href="#5-3-无声失效原则" class="headerlink" title="5.3 无声失效原则"></a>5.3 无声失效原则</h3><p>当客户端请求带可选功能参数的服务时（包含带可选的头部信息），<strong>必须</strong>对服务端的返回格式有一定兼容性，<strong>可以</strong>忽略这些特定功能。</p>
<p>例如 分页数、排序、国际化等自定义参数的支持和返回格式的兼容。</p>
<h2 id="6-基础原则"><a href="#6-基础原则" class="headerlink" title="6. 基础原则"></a>6. 基础原则</h2><h3 id="6-1-URL结构☆"><a href="#6-1-URL结构☆" class="headerlink" title="6.1 URL结构☆"></a>6.1 URL结构☆</h3><p>结构约束：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">&#123;schema&#125;://&#123;serviceRoot&#125;/&#123;collection&#125;[/&#123;id&#125;]</span><br><span class="line">&#123;schema&#125;://&#123;host&#125;:&#123;port&#125;/&#123;prefix&#125;/&#123;version&#125;/&#123;collection&#125;[/&#123;id&#125;]</span><br></pre></td></tr></table></figure>

<ul>
<li>schema - API接口支持的协议（http或https）</li>
<li>{serviceRoot} – 站点URL (site URL) + 服务的根路径的组合<ul>
<li>host - 服务的域名或IP</li>
<li>port - 服务的端口</li>
<li>prefix - 接口的标识前缀：”&#x2F;api”</li>
<li>version - 接口的版本</li>
</ul>
</li>
<li>{collection} – 集合的名称，复数</li>
<li>{id} – 唯一标识属性的值，唯一标识中原则上不允许使用”&#x2F;“，如果业务需要，一定要带”\“转义。</li>
</ul>
<p>API URL路径结构应该是友好的易于理解的。甚至用户无需通过阅读API文档能够猜出相关结构和路径。</p>
<p>正例：<a href="https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/memorys">https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/memorys</a></p>
<p>显而易见，这是一个： 版本为v1.0的 获取标识为“JHF8UE6H5W34D”探针内存数据资源 的API。</p>
<p>反例：<a href="https://ailpha.com/api/EWS/OData/agents(&#39;JHF8UE6H5W34D&#39;)/Folders(&#39;MEM&#39;)">https://ailpha.com/api/EWS/OData/agents(&#39;JHF8UE6H5W34D&#39;)/Folders(&#39;MEM&#39;)</a></p>
<p>虽然也能理解部分含义，但结构混乱，解析困难且不友好。</p>
<p>URL结尾为<strong>资源（resource）</strong>，既然是资源，必须是名词，必须为复数形式。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/agent/list?agentType=ainta</span><br><span class="line">GET /api/agent/getAgentById?id=JHF8UE6H5W34D</span><br><span class="line">POST /api/agent/deleteAgentById?id=JHF8UE6H5W34D</span><br></pre></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1.0/agents?agentType=ainta</span><br><span class="line">GET /api/v1.0/agents/JHF8UE6H5W34D</span><br><span class="line">DELETE /api/v1.0/agents/JHF8UE6H5W34D</span><br></pre></td></tr></table></figure>



<h3 id="6-2-URL长度"><a href="#6-2-URL长度" class="headerlink" title="6.2 URL长度"></a>6.2 URL长度</h3><p>HTTP&#x2F;1.1 标准中并未对请求长度做限制，其中包含URL。<br>RFC 7230 原文：</p>
<blockquote>
<p>HTTP does not place a predefined limit on the length of a request-line. […] A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code.</p>
</blockquote>
<p>对应翻译：</p>
<blockquote>
<p>HTTP不会对请求行的长度设置预定义的限制。[…]如果服务器接收的请求目标比它希望解析的任何URI都长，则必须使用414（URI过长）状态码进行响应。</p>
</blockquote>
<p>此处约定URL长度不超过2,000个字符，约定依据是IE所能接收的URL长度为2083（其他浏览器也有限定但大于这个值）。</p>
<p>不同客户端支持的最长 URL 长度参见以下资料：</p>
<ul>
<li><a href="http://stackoverflow.com/a/417184">http://stackoverflow.com/a/417184</a></li>
<li><a href="https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/">https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/</a></li>
</ul>
<h3 id="6-3-规范标识符"><a href="#6-3-规范标识符" class="headerlink" title="6.3 规范标识符"></a>6.3 规范标识符</h3><p>在URL中，针对具体的资源，必须提供一个唯一且稳定的标识符。</p>
<p>包含规范标识符的URL的一个例子依然是6.1中的正例：</p>
<p><a href="https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/memory">https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/memory</a></p>
<p>标识符推荐使用有含义的唯一性索引字段（IP、邮箱），也可以是暴露给客户端的主键。</p>
<h3 id="6-4-操作方法☆"><a href="#6-4-操作方法☆" class="headerlink" title="6.4 操作方法☆"></a>6.4 操作方法☆</h3><p>对于资源的具体操作类型，由HTTP Method表示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>是否幂等</th>
</tr>
</thead>
<tbody><tr>
<td><strong>GET</strong></td>
<td>返回资源的当前值<br />成功状态码：200（OK）</td>
<td>✔</td>
</tr>
<tr>
<td><strong>POST</strong></td>
<td>根据提供的数据创建一个新资源，或者提交一个操作<br />成功状态码：201（Created）</td>
<td></td>
</tr>
<tr>
<td><strong>PUT</strong></td>
<td>更新资源（客户端提供改变后的完整资源，或者称：替换资源）<br />成功状态码：200（OK）</td>
<td>✔</td>
</tr>
<tr>
<td><strong>PATCH</strong></td>
<td>更新资源（客户端提供改变的属性）<br />成功状态码：200（OK）<br />针对不存在的资源的 PATCH 调用必须使用409（Conflict）响应错误</td>
<td></td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>删除资源<br />成功状态码：204（No Content）</td>
<td>✔</td>
</tr>
<tr>
<td>HEAD</td>
<td>返回GET响应的资源的元数据，不常用<br />成功状态码：200（OK）</td>
<td>✔</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>获取关于请求的信息，不常用<br />成功状态码：200（OK）</td>
<td>✔</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /agents：列出所有探针</span><br><span class="line">POST /agents：新建一个探针</span><br><span class="line">GET /agents/&#123;agentCode&#125;：获取某个指定探针的信息</span><br><span class="line">PUT /agents/&#123;agentCode&#125;：更新某个指定探针的信息（提供该探针的全部信息）</span><br><span class="line">PATCH /agents/&#123;agentCode&#125;：更新某个指定探针的的信息（提供该探针的部分信息）</span><br><span class="line">DELETE /agents/&#123;agentCode&#125;：删除某个指定探针</span><br><span class="line">GET /agents/&#123;agentCode&#125;/monitors：列出某个指定探针的所有监控数据</span><br><span class="line">DELETE /agents/&#123;agentCode&#125;/monitors/&#123;monitorId&#125;：删除某个指定探针的指定监控数据</span><br></pre></td></tr></table></figure>

<h3 id="6-5-标准请求头"><a href="#6-5-标准请求头" class="headerlink" title="6.5 标准请求头"></a>6.5 标准请求头</h3><p>当前有规范的请求头参数如下所示，使用这些请求头参数不是强制性的，但如果使用它们则必须始终一致地遵循 AiLPHA REST API指南服务使用。</p>
<table>
<thead>
<tr>
<th>请求头参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>Content type</td>
<td>请求的响应内容类型<br />一般为 Accept: application&#x2F;json</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>“en”, “cn”, etc.</td>
<td>指定响应的首选语言。<br />AiLPHA平台支持国际化（i18n），无特殊情况必须使用Accept-Language来指定语言。</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>Charset type like “UTF-8”</td>
<td>指定响应的编码。默认值是UTF-8。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>Content type</td>
<td>请求正文的媒体（Mime）类型 (PUT&#x2F;POST&#x2F;PATCH)<br />媒体类型在<a href="https://www.rfc-editor.org/rfc/rfc2854.txt">RFC2854</a>有明确定义</td>
</tr>
<tr>
<td>Prefer</td>
<td>return&#x3D;minimal, return&#x3D;representation</td>
<td>如果指定了return &#x3D; minimal首选项，则服务应该返回一个空主体（empty body）以响应一次成功的插入或更新。<br />如果指定了return &#x3D; representation，则服务应该返回创建或更新的资源。<br />使用场景：客户端有时会需要从响应中获得资源，但有时响应会对带宽造成太大的影响而不想获得资源。</td>
</tr>
</tbody></table>
<h3 id="6-6-标准响应头"><a href="#6-6-标准响应头" class="headerlink" title="6.6 标准响应头"></a>6.6 标准响应头</h3><p>服务应该返回以下响应头参数。</p>
<table>
<thead>
<tr>
<th>响应头参数</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>Content type</td>
<td>请求正文的媒体（Mime）类型 (PUT&#x2F;POST&#x2F;PATCH)<br />媒体类型在<a href="https://www.rfc-editor.org/rfc/rfc2854.txt">RFC2854</a>有明确定义</td>
</tr>
<tr>
<td>X-Frame-Options</td>
<td>DENY、SAMEORIGIN、ALLOW-FROM uri、NONE</td>
<td>指示允许一个页面可否在 &lt;frame&gt;,\ &lt;&#x2F;iframe&gt; 或者 &lt;object&gt; 中展现的标记。<br />在AiLPHA中为全局配置，无特殊需要接口开发不指定。</td>
</tr>
</tbody></table>
<h3 id="6-7-状态码☆"><a href="#6-7-状态码☆" class="headerlink" title="6.7 状态码☆"></a>6.7 状态码☆</h3><p>应使用标准HTTP状态码作为响应状态码</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<ul>
<li><code>1xx</code>：相关信息</li>
<li><code>2xx</code>：操作成功</li>
<li><code>3xx</code>：重定向</li>
<li><code>4xx</code>：客户端错误</li>
<li><code>5xx</code>：服务器错误</li>
</ul>
<p>这五大类总共包含<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">100多种</a>状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>
<p>API 不需要<code>1xx</code>状态码，下面介绍其他四类状态码的精确含义。</p>
<h4 id="6-7-1-常用状态码☆"><a href="#6-7-1-常用状态码☆" class="headerlink" title="6.7.1 常用状态码☆"></a>6.7.1 常用状态码☆</h4><p>以下列举了常用的状态码，表述其使用场景及对应使用说明。</p>
<h5 id="2xx状态码"><a href="#2xx状态码" class="headerlink" title="2xx状态码"></a>2xx状态码</h5><p><code>200</code>状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p>
<blockquote>
<ul>
<li>GET: 200 OK</li>
<li>POST: 201 Created</li>
<li>PUT: 200 OK</li>
<li>PATCH: 200 OK</li>
<li>DELETE: 204 No Content</li>
</ul>
</blockquote>
<p>上面代码中，<code>POST</code>返回<code>201</code>状态码，表示生成了新的资源；<code>DELETE</code>返回<code>204</code>状态码，表示资源已经不存在。</p>
<p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。<br>下面是一个例子。</p>
 <figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">202</span> Accepted</span><br><span class="line">&#123;</span><br><span class="line">  &quot;task&quot;: &#123;</span><br><span class="line">    &quot;href&quot;: &quot;/api/update-jobs/12345&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;12345&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4xx-状态码"><a href="#4xx-状态码" class="headerlink" title="4xx 状态码"></a>4xx 状态码</h5><p><code>4xx</code>状态码表示客户端错误，主要有下面几种。</p>
<p><code>400 Bad Request</code>：服务器不理解客户端的请求，未做任何处理。</p>
<p><code>401 Unauthorized</code>：用户未提供身份验证凭据，或者没有通过身份验证。</p>
<p><code>403 Forbidden</code>：用户通过了身份验证，但是不具有访问资源所需的权限。</p>
<p><code>404 Not Found</code>：所请求的资源不存在，或不可用。</p>
<p><code>405 Method Not Allowed</code>：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</p>
<p><code>415 Unsupported Media Type</code>：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</p>
<p><code>422 Unprocessable Entity</code> ：客户端上传的附件无法处理，导致请求失败。</p>
<p><code>429 Too Many Requests</code>：客户端的请求次数超过限额。</p>
<h5 id="5xx-状态码"><a href="#5xx-状态码" class="headerlink" title="5xx 状态码"></a>5xx 状态码</h5><p><code>5xx</code>状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p>
<p><code>500 Internal Server Error</code>：客户端请求有效，服务器处理时发生了意外。</p>
<p><code>503 Service Unavailable</code>：服务器无法处理请求，一般用于网站维护状态。</p>
<h4 id="6-7-2-状态码表"><a href="#6-7-2-状态码表" class="headerlink" title="6.7.2 状态码表"></a>6.7.2 状态码表</h4><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">用户未提供身份验证凭据，或者没有通过身份验证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">用户通过了身份验证，但是不具有访问资源所需的权限</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">所请求的资源不存在，或不可用</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<p>更多状态码详情，参见：<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">RFC2616-sec10</a></p>
<h3 id="6-8-响应格式☆"><a href="#6-8-响应格式☆" class="headerlink" title="6.8 响应格式☆"></a>6.8 响应格式☆</h3><p>此章节为重点，此处规定了可读性较好并且一致的响应结果，开发人员使用 HTTP工具方法处理响应（TODO）。</p>
<p>没有特殊需求，推荐使用JSON作为传输格式。JSON属性名应该采用驼峰命名规范 (<a href="https://tools.ietf.org/html/rfc3864">RFC3864</a>)。</p>
<h4 id="6-8-1-响应格式指定"><a href="#6-8-1-响应格式指定" class="headerlink" title="6.8.1 响应格式指定"></a>6.8.1 响应格式指定</h4><p>客户端应该使用Accept参数请求响应格式。服务端可以选择性地忽略，如客户端发送多个Accept参数值，服务可以选择其中一个格式进行响应。</p>
<p>默认的响应格式（没有指定Accept）应该是application&#x2F;json。</p>
<p><code>Accept: application/json</code></p>
<table>
<thead>
<tr>
<th>请求参数类型</th>
<th>响应类型</th>
</tr>
</thead>
<tbody><tr>
<td>application&#x2F;json</td>
<td>必须是返回json格式</td>
</tr>
</tbody></table>
<h4 id="6-8-2-标准响应规范☆"><a href="#6-8-2-标准响应规范☆" class="headerlink" title="6.8.2 标准响应规范☆"></a>6.8.2 标准响应规范☆</h4><p>对于调用成功的情况，规定统一的成功响应的字段规范。</p>
<h5 id="SuccessResponse"><a href="#SuccessResponse" class="headerlink" title="SuccessResponse"></a>SuccessResponse</h5><p>对象类型</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否必填</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>data</code></td>
<td>Object、Object[] …</td>
<td>✔</td>
<td>一般为操作的资源，也可以是客户端约定的标识</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td></td>
<td>其他业务需要的拓展字段</td>
</tr>
</tbody></table>
<p>成功响应<strong>必须</strong>是单个JSON对象。为保证一致性，该对象必须有一个名为“data”的键，其值类型按不同情况返回。</p>
<p>如果是单个资源的获取，“data”必须是单个JSON对象。</p>
<p>如果是多个资源的获取，“data”必须是包含0-n个对象的JSON数组。</p>
<h5 id="成功响应样例"><a href="#成功响应样例" class="headerlink" title="成功响应样例"></a>成功响应样例</h5><p>例子「单个对象」：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /api/agent-configs/soc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;agentType&quot;:&quot;soc&quot;,</span><br><span class="line">    &quot;softVersion&quot;:&quot;3.0.1&quot;,</span><br><span class="line">    &quot;config&quot;:&quot;&quot;,</span><br><span class="line">    &quot;version&quot;:1611054006000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子「多个对象」</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /api/agent-configs</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;agentType&quot;:&quot;soc&quot;,</span><br><span class="line">    &quot;softVersion&quot;:&quot;3.0.1&quot;,</span><br><span class="line">    &quot;config&quot;:&quot;&quot;,</span><br><span class="line">    &quot;version&quot;:1611054006000</span><br><span class="line">  	&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;agentType&quot;:&quot;ainta&quot;,</span><br><span class="line">    &quot;softVersion&quot;:&quot;1.1.3&quot;,</span><br><span class="line">    &quot;config&quot;:&quot;&quot;,</span><br><span class="line">    &quot;version&quot;:1611054006000</span><br><span class="line">  	&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /api/agent-configs</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例子「成功执行」</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE /api/agents/HI6J5OEJ23FKH83W</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-8-3-错误响应规范☆"><a href="#6-8-3-错误响应规范☆" class="headerlink" title="6.8.3 错误响应规范☆"></a>6.8.3 错误响应规范☆</h4><p>对于调用不成功的情况，规定统一的错误响应的字段规范。</p>
<h5 id="ErrorResponse"><a href="#ErrorResponse" class="headerlink" title="ErrorResponse"></a>ErrorResponse</h5><p>对象类型</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否必填</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>error</code></td>
<td>Error</td>
<td>✔</td>
<td>错误对象</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td></td>
<td>其他业务需要的拓展字段</td>
</tr>
</tbody></table>
<h5 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h5><p>对象类型</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>是否必填</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>String</td>
<td>✔</td>
<td>服务器定义的固定错误代码，禁止随意定义，必须跟随版本发布。</td>
</tr>
<tr>
<td><code>message</code></td>
<td>String</td>
<td>✔</td>
<td><strong>必须</strong>是可读且易于理解，可作为面向用户的提示消息。</td>
</tr>
<tr>
<td><code>target</code></td>
<td>String</td>
<td></td>
<td>具体的目标。</td>
</tr>
<tr>
<td><code>details</code></td>
<td>Error[]</td>
<td></td>
<td>更细分的多个错误用错误组表示，Error对象数组类型。</td>
</tr>
<tr>
<td><code>innererror</code></td>
<td>InnerError</td>
<td></td>
<td>包含比当前对象更具体的错误信息的对象，InnerError对象类型。</td>
</tr>
</tbody></table>
<p>错误响应<strong>必须</strong>是单个JSON对象。该对象必须有一个名为“error”的键，其值<strong>必须</strong>是JSON对象。</p>
<p>error对象<strong>必须</strong>包含名称“code”和“message”的键值对，并且<strong>推荐</strong>包含譬如“target”、“details”和 “innererror” 的键值对。</p>
<p>“code”值是该服端务定义的错误代码，应该简单可读。与响应中指定的HTTP错误代码相比，此代码用作定位更具体的错误。</p>
<h5 id="InnerError"><a href="#InnerError" class="headerlink" title="InnerError"></a>InnerError</h5><p>对象类型</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>code</code></td>
<td>String</td>
<td>✔</td>
<td>比包含错误的提供的更具体的错误代码，允许自行拓展，区别于Error对象中的code。</td>
</tr>
<tr>
<td><code>innererror</code></td>
<td>InnerError</td>
<td></td>
<td>包含比当前对象更具体的错误信息的对象，InnerError对象类型。<br />最重要的是支持嵌套。</td>
</tr>
</tbody></table>
<p>如果要指明更为具体的错误，<strong>应该</strong>在“innererror” 对象中定义。</p>
<p>“message” 键值对的值<strong>必须</strong>是错误提示消息，<strong>必须</strong>是可读且易于理解，可作为面向用户的提示消息。</p>
<p>“target” 键值对的值 是指向错误的具体的目标（例如，错误中属性的名称）。</p>
<p>“details”键值对的值 必须是JSON对象数组，数组中的对象通常表示请求期间发生的不同的、相关的错误。</p>
<h5 id="Error-code"><a href="#Error-code" class="headerlink" title="Error.code"></a>Error.code</h5><p>通用的错误code（待完善）</p>
<table>
<thead>
<tr>
<th align="left">错误代码</th>
<th>响应码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BadArgument</td>
<td>400</td>
<td align="left">提供的参数无效</td>
</tr>
<tr>
<td align="left">BadUserArgument</td>
<td>400</td>
<td align="left">提供的用户参数无效</td>
</tr>
<tr>
<td align="left">ErrorUnsupportedOrderBy</td>
<td>400</td>
<td align="left">资源不支持排序 或 不支持使用指定的字段排序</td>
</tr>
<tr>
<td align="left">ErrorUnsupportedPaging</td>
<td>400</td>
<td align="left">资源不支持分页请求</td>
</tr>
<tr>
<td align="left">InvalidOperation</td>
<td>400</td>
<td align="left">请求在当前上下文中无效<br />例子：<br />JOB提交中，不可修改。<br />模型与请求版本不兼容无法更新。</td>
</tr>
<tr>
<td align="left">Unauthorized</td>
<td>401</td>
<td align="left">请求未获授权，无法访问资源。</td>
</tr>
<tr>
<td align="left">InvalidApiKey</td>
<td>401</td>
<td align="left">无效apiKey。</td>
</tr>
<tr>
<td align="left">NotFound</td>
<td>404</td>
<td align="left">找不到资源。</td>
</tr>
<tr>
<td align="left">RequestTimeout</td>
<td>408</td>
<td align="left">无法在允许的时间内完成该操作。</td>
</tr>
<tr>
<td align="left">Conflict</td>
<td>409</td>
<td align="left">请求资源冲突，POST已存在资源 或 PATCH不存在资源。</td>
</tr>
<tr>
<td align="left">Overlimit</td>
<td>409</td>
<td align="left">请求资源超出系统限制。</td>
</tr>
<tr>
<td align="left">InternalError</td>
<td>500</td>
<td align="left">执行时遇到内部错误。<br />具体异常类型自定义，放入innererror</td>
</tr>
<tr>
<td align="left">ServiceUnavailable</td>
<td>503</td>
<td align="left">服务暂时不可用。</td>
</tr>
<tr>
<td align="left">GatewayTimeout</td>
<td>504</td>
<td align="left">无法在允许的时间内完成该操作。</td>
</tr>
</tbody></table>
<h5 id="错误响应样例"><a href="#错误响应样例" class="headerlink" title="错误响应样例"></a>错误响应样例</h5><p>例子「带有”innererror“」</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BadArgument&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Previous passwords may not be reused&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;innererror&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PasswordError&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;innererror&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PasswordDoesNotMeetPolicy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;maxLength&quot;</span><span class="punctuation">:</span> <span class="string">&quot;64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;characterTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;lowerCase&quot;</span><span class="punctuation">,</span><span class="string">&quot;upperCase&quot;</span><span class="punctuation">,</span><span class="string">&quot;number&quot;</span><span class="punctuation">,</span><span class="string">&quot;symbol&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minDistinctCharacterTypes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;innererror&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PasswordReuseNotAllowed&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在本例中，基本的错误码是“BadArgument”，而“innererror”中提供了更具体的错误代码。 “PasswordReuseNotAllowed”代码可能是在之后的迭代中新增的，之前只返回“PasswordDoesNotMeetPolicy”。 这种增量型的添加方式并不会破坏老的客户端的处理过程，而又可以给开发者一些更详细的信息。</p>
<p>例子「带有“details”」</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BadArgument&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Multiple errors in ContactInfo data&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ContactInfo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NullValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PhoneNumber&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Phone number must not be null&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NullValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LastName&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Last name must not be null&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MalformedValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Address&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Address is not valid&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在本例中，请求存在多处问题，每个错误都列在 “details” 字段中进行返回了。</p>
<h4 id="6-8-4-不支持的请求"><a href="#6-8-4-不支持的请求" class="headerlink" title="6.8.4 不支持的请求"></a>6.8.4 不支持的请求</h4><p>客户端可以请求当前不受支持的功能。 但服务端必须响应与本节一致的有效但不受支持的请求。</p>
<p>如果服务不支持一些功能，则必须在客户端请求API时返回错误响应。 </p>
<p>举例：</p>
<ul>
<li>用key在集合中检索，例如：<code>https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D</code></li>
<li>用条件过滤集合，例如：<code>https://ailpha.com/api/v1.0/agents?agentType=soc</code></li>
<li>通过_$page_和_$size_进行分页，例如：<code>https://ailpha.com/api/v1.0/agents?$page=5&amp;$size=10</code></li>
<li>按_$orderBy_排序，例如：<code>https://ailpha.com/api/v1.0/agents?$orderBy=createTime desc</code></li>
</ul>
<p>错误响应<strong>必须</strong>是来自4xx系列的HTTP状态码，表示无法满足请求。</p>
<p>除非更具体的错误状态适用于给定的请求，否则服务应该返回“400 Bad Request”。服务应该在响应消息中包含足够的详细信息，以便开发人员明确不支持请求的哪个部分。</p>
<p>例子：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://ailpha.com/api/v1.0/agents?$orderBy=name</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br></pre></td></tr></table></figure>

<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;code&quot;: &quot;ErrorUnsupportedOrderBy&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Ordering by name is not supported.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-资源集合"><a href="#7-资源集合" class="headerlink" title="7. 资源集合"></a>7. 资源集合</h2><h3 id="7-1-资源标识"><a href="#7-1-资源标识" class="headerlink" title="7.1 资源标识"></a>7.1 资源标识</h3><p>资源集合中每个具体资源推荐使用持久标识符（主键），含义等同于6.3章节的定义。</p>
<h3 id="7-2-序列化"><a href="#7-2-序列化" class="headerlink" title="7.2 序列化"></a>7.2 序列化</h3><p>使用JSON作为序列化标准格式。</p>
<h3 id="7-3-集合的URL"><a href="#7-3-集合的URL" class="headerlink" title="7.3 集合的URL"></a>7.3 集合的URL</h3><p>URL中集合直接定义在根路径之后，或者在另一个具体资源之后。</p>
<p>集合元素本质是 <strong>资源（resource）</strong>，既然是资源，必须是名词，必须为复数形式。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://&#123;serviceRoot&#125;/&#123;collection&#125;/&#123;id&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>{serviceRoot} – 站点URL (site URL) + 服务的根路径的组合</li>
<li>{collection} – 集合的名称，复数</li>
<li>{id} – 唯一标识属性的值，唯一标识中原则上不允许使用”&#x2F;“，如果业务需要，一定要带”\“转义。</li>
</ul>
<p>例子：</p>
<p><strong>常规资源集合</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents</span><br></pre></td></tr></table></figure>

<p><strong>嵌套资源集合和属性</strong></p>
<p>集合项可以包含其他集合。例如，探针集合可能包含多个内存数据资源：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/memorys</span><br></pre></td></tr></table></figure>

<h3 id="7-3-通用子资源"><a href="#7-3-通用子资源" class="headerlink" title="7.3 通用子资源"></a>7.3 通用子资源</h3><p>资源集合根据业务场景及具体数据定义，但部分子资源对多数资源来说通用的，此处定义的通用子资源如涉及，每个资源定义必须遵守。</p>
<h4 id="7-4-1-files（文件子资源）"><a href="#7-4-1-files（文件子资源）" class="headerlink" title="7.4.1 files（文件子资源）"></a>7.4.1 files（文件子资源）</h4><p><em>files</em>表述的是一个资源集合或具体资源的文件子资源，常用于 导入、导出 场景。</p>
<p>使用可选过滤参数<em>type</em>来区分不同文件类型，服务端<strong>必须</strong>定义默认type，当未指定type时使用默认文件类型。服务端也<strong>应该</strong>在只支持一种默认type的时候，可以忽略客户端发来的type参数。</p>
<p>导出或下载使用GET，表述意义为获取资源的文件子资源。</p>
<p>导入或上传使用POST，表述意义为创建资源的文件子资源。</p>
<p>例子：</p>
<p><strong>获取资源集合的文件子资源（导出资源集合）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents/files</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/octet-stream</span><br></pre></td></tr></table></figure>

<p><strong>获取特定资源的文件子资源（导出特定资源）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/files?type=docx</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/octet-stream</span><br></pre></td></tr></table></figure>

<p><strong>创建资源集合的文件子资源（导入资源集合）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/agents/files</span><br></pre></td></tr></table></figure>

<p><strong>创建特定资源的文件子资源（导入特定资源）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D/files?type=docx</span><br></pre></td></tr></table></figure>

<h4 id="7-4-2-synchronizations（同步子资源）"><a href="#7-4-2-synchronizations（同步子资源）" class="headerlink" title="7.4.2 synchronizations（同步子资源）"></a>7.4.2 synchronizations（同步子资源）</h4><p><em>synchronizations</em>表述的是从一个资源集合同步全部或部分数据到另一个资源集合。资源集合可以是内部的也可以是外部的。</p>
<p>一般情况下，创建同步子资源是异步的，响应码应该返回202。</p>
<p>例子：</p>
 <figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/assets/synchronizations</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line"> 	&quot;from&quot;:&quot;https://soc.com/api/assets&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">202</span> Accepted</span><br><span class="line">&#123;</span><br><span class="line">  &quot;task&quot;: &#123;</span><br><span class="line">    &quot;href&quot;: &quot;/api/v1.0/assets/synchronizations/12345&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;12345&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-4-3-connectivities（连通性子资源）"><a href="#7-4-3-connectivities（连通性子资源）" class="headerlink" title="7.4.3 connectivities（连通性子资源）"></a>7.4.3 connectivities（连通性子资源）</h4><p><em>connectivities</em>表述的是一个资源集合或具体资源的连通性子资源，常用于检测资源（通常是设备类资源）的连通性。</p>
<p>连通性的检测包含几类：系统 -&gt; 资源，资源 -&gt; 资源，资源 -&gt; 外部实体。</p>
<p>例子：</p>
<p><strong>创建特定资源的连通性子资源（检测特定资源的连通性 - 常用）</strong></p>
<ul>
<li>测试系统对特定资产连通性。系统 -&gt; 资源。</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/assets/JHF8UE6H5W34D/connectivities</span><br></pre></td></tr></table></figure>

<ul>
<li>测试邮件服务资源对外部邮箱的连通性。资源 -&gt; 外部实体。</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/email-servers/JHF8UE6H5W34D/connectivities</span><br><span class="line">&#123;</span><br><span class="line">		&quot;to&quot;:&quot;ailpha@ailpha.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建资源集合的连通性子资源（检测资源集合的连通性）</strong></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/assets/connectivities</span><br></pre></td></tr></table></figure>



<h3 id="7-5-排序"><a href="#7-5-排序" class="headerlink" title="7.5 排序"></a>7.5 排序</h3><p><em>$orderBy</em> 参数允许客户端对集合查询的结果进行排序。</p>
<p><em>$orderBy</em> 参数的值包含可以是多个，用逗号分隔的。 可以指定排序方式（asc 升序、desc 降序），空格分隔，默认为升序。</p>
<p>空值（NULL）排序必须“小于”非空值。</p>
<p>如果不支持排序字段，需统一返回 400 Bad Request，响应不支持的参数类型。</p>
<p>例子：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents?$orderBy=name</span><br></pre></td></tr></table></figure>

<p>按名称正序排。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents?$orderBy=name desc</span><br></pre></td></tr></table></figure>

<p>按名称倒序排。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents?$orderBy=name desc,createTime</span><br></pre></td></tr></table></figure>

<p>按名称倒序排，再按创建时间排。</p>
<p>响应内容中，资源必须放在data内，同时<strong>必须</strong>返回*$orderBy*字段。</p>
<p>响应举例：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents?$orderBy=name desc,createTime</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  &quot;$orderBy&quot;: &quot;name desc,createTime&quot;,</span><br><span class="line">  &quot;data&quot;: [...],</span><br><span class="line">  &quot;total&quot;:100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-分页"><a href="#7-6-分页" class="headerlink" title="7.6 分页"></a>7.6 分页</h3><p>客户端可以使用 <em>$page</em>和*$size*查询参数来指定页数和每页的数量。</p>
<p> <em>$page</em>和 <em>$size</em>参数的值是正整数（1-N）。</p>
<p>如果不支持分页字段，需统一返回 400 Bad Request，响应不支持的参数类型。</p>
<p>响应内容中，资源必须放在data内，同时<strong>必须</strong>返回*$page<em>、</em>$size*字段，<strong>必须</strong>返回total字段。</p>
<p>例子：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://ailpha.com/api/v1.0/agents?$page=5&amp;$size=10</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  ...,</span><br><span class="line">  &quot;$page&quot;: 5,</span><br><span class="line">  &quot;$size&quot;: 10,</span><br><span class="line">  &quot;data&quot;: [...],</span><br><span class="line">  &quot;total&quot;:100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-7-批量操作"><a href="#7-7-批量操作" class="headerlink" title="7.7 批量操作"></a>7.7 批量操作</h3><p>对 资源的批量操作 准确的理解应该是 对资源集合的操作。以下几个例子来助于理解。</p>
<p>例子：</p>
<p>批量获取</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET https://ailpha.com/api/v1.0/agents</span><br></pre></td></tr></table></figure>

<p>批量新增</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST https://ailpha.com/api/v1.0/agents</span><br><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量更新（提供改变的资源属性）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PATCH https://ailpha.com/api/v1.0/agents</span><br><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量替换（提供改变后的完整资源）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT https://ailpha.com/api/v1.0/agents</span><br><span class="line">&#123;</span><br><span class="line">	&quot;data&quot;:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量删除</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"># 根据IDs删除</span><br><span class="line">DELETE https://ailpha.com/api/v1.0/agents/JHF8UE6H5W34D,GDSRUEJHFR87K,HJHAS45SDAOL</span><br><span class="line"># 根据条件删除</span><br><span class="line">DELETE https://ailpha.com/api/v1.0/agents?agentType=&quot;ainta&quot;</span><br></pre></td></tr></table></figure>



<h2 id="8-JSON标准化"><a href="#8-JSON标准化" class="headerlink" title="8. JSON标准化"></a>8. JSON标准化</h2><h3 id="8-1-基本类型"><a href="#8-1-基本类型" class="headerlink" title="8.1 基本类型"></a>8.1 基本类型</h3><p>必须按照<a href="https://www.rfc-editor.org/rfc/rfc8259.txt">RFC8259</a>的规则将原始值序列化为JSON。JSON文本必须使用UTF-8 <a href="https://www.rfc-editor.org/info/rfc3629">RFC3629</a> 编码。</p>
<p>JSON值必须是字符串、数字、布尔值、对象、数组、null，取值<strong>禁止</strong>超过这个范畴。</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>String</strong></td>
<td>字符串的表示类似于C系列编程语言中使用的约定。<strong>字符串以双引号开头和结尾</strong>。所有Unicode字符都可以放在引号中，但必须转义的字符除外：引号、反斜线分隔符\和控制字符(U+0000到U+001 F)。</td>
<td>“hello”  “\u4f60\u597d”</td>
</tr>
<tr>
<td><strong>Number</strong></td>
<td>数字的表示与大多数编程语言中使用的表示类似。<strong>一个数字用十进制数字以基数10表示</strong>。它包含一个整数分量，其前缀可以是可选减号，后面可以是分数部分和&#x2F;或指数部分。不允许前导零。</td>
<td>1234  123.22</td>
</tr>
<tr>
<td><strong>Boolean</strong></td>
<td><strong>值为 true 或 false</strong>  。</td>
<td>true  false</td>
</tr>
<tr>
<td><strong>Object</strong></td>
<td><strong>对象结构表示为围绕零或多个名称&#x2F;值对(或多个成员)的一对花括号。名称是字符串。在每个名称之后加上一个冒号，将名称与值分隔开来。一个逗号将值与接下来的名称分隔开来。对象中的名称应该是唯一的</strong>。</td>
<td>{“a”:1,  “b”:true}</td>
</tr>
<tr>
<td><strong>Array</strong></td>
<td><strong>数组结构表示为围绕零个或多个值(或多个元素)的方括号。元素用逗号分隔</strong>。<br />不要求数组中的值具有相同的类型。</td>
<td>[1,2,3,4]</td>
</tr>
<tr>
<td><strong>Null</strong></td>
<td>空。</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：</p>
<p><strong>64位整数的重要说明：</strong> JavaScript将静默截断大于“Number.MAX_SAFE_INTEGER”（2 ^ 53-1）的整数或小于“Number.MIN_SAFE_INTEGER”（-2 ^ 53 + 1）的数字。 <strong>如果数值类型值过大，必须将该值作为字符串返回</strong>。</p>
<h3 id="8-2-空值"><a href="#8-2-空值" class="headerlink" title="8.2 空值"></a>8.2 空值</h3><p>为了保证接口的一致性，对空值做如下约束：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th>空值约束</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String</strong></td>
<td>“”</td>
</tr>
<tr>
<td><strong>Number</strong></td>
<td>0</td>
</tr>
<tr>
<td><strong>Boolean</strong></td>
<td>不允许存在空值</td>
</tr>
<tr>
<td><strong>Object</strong></td>
<td>{}</td>
</tr>
<tr>
<td><strong>Array</strong></td>
<td>[]</td>
</tr>
</tbody></table>
<h3 id="8-3-时间类型"><a href="#8-3-时间类型" class="headerlink" title="8.3 时间类型"></a>8.3 时间类型</h3><p>时间字段在各个接口中的定义都不要显得混乱且不统一，<strong>必须</strong>按本节一致的约定执行。</p>
<h4 id="8-3-1-日期-时间约定"><a href="#8-3-1-日期-时间约定" class="headerlink" title="8.3.1 日期\时间约定"></a>8.3.1 日期\时间约定</h4><p>通常情况下，对于日期\时间在不同的国家、不同的业务场景下会有相当多种类的不同表示。</p>
<p>为保证接口的一致性，对日期\时间做如下约束：</p>
<ul>
<li>接口层面<strong>必须</strong>使用Unix时间戳传递日期\时间，<strong>必须</strong>毫秒级。例如：1611469304000。</li>
<li>建议后端时间存储也采用Unix时间戳存储。</li>
<li>前端根据用户的时区、业务场景自行处理呈现。</li>
</ul>
<h4 id="8-3-2-持续时长"><a href="#8-3-2-持续时长" class="headerlink" title="8.3.2 持续时长"></a>8.3.2 持续时长</h4><p>按照[ISO 8601] <a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">wikipedia-iso8601-durations</a>进行序列化。</p>
<p>持续时间“由格式’P [n] Y [n] M [n] DT [n] H [n] M [n] S&#96;表示。”</p>
<ul>
<li>P是在持续时间表示开始时放置的持续时间指示符（“period”）。</li>
<li>Y是年份指示符，它遵循年数值。</li>
<li>M是月份指示符，它遵循月数值。</li>
<li>W是周指示符，它遵循周数值。</li>
<li>D是遵循天数值的日期指示符。</li>
<li>T是在表示的时间分量之前的时间指示符。</li>
<li>H是小时指示符，它遵循小时数值。</li>
<li>M是遵循分钟数值的分钟指示符。</li>
<li>S是秒指示符，它遵循秒数的值。</li>
</ul>
<p>例如，</p>
<p>“P3Y6M4DT12H30M5S”表示“：”三年，六个月，四天，十二个小时，三十分钟加五秒” 的持续时间。</p>
<h2 id="9-版本号"><a href="#9-版本号" class="headerlink" title="9. 版本号"></a>9. 版本号</h2><p>**所有符合AiLPHA REST API准则的API都必须支持显式版本控制。 **</p>
<h3 id="9-1-版本定义"><a href="#9-1-版本定义" class="headerlink" title="9.1 版本定义"></a>9.1 版本定义</h3><p>使用major.minor格式进行版本定义。</p>
<p>版本定义在&#x2F;api路径之后。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://ailpha.com/api/v1.0/agents</span><br></pre></td></tr></table></figure>

<h3 id="9-2-版本更新说明"><a href="#9-2-版本更新说明" class="headerlink" title="9.2 版本更新说明"></a>9.2 版本更新说明</h3><p><strong>必须</strong>保留历史版本接口，除非你能确认该接口已无任何客户端在使用。</p>
<p>不更新版本的情况下，允许修改接口返回，但只允许新增属性，<strong>禁止</strong>删除和修改原属性（参见5.1章节「字段忽略原则」）。</p>
<h2 id="10-命名准则"><a href="#10-命名准则" class="headerlink" title="10. 命名准则"></a>10. 命名准则</h2><h3 id="10-1-建议"><a href="#10-1-建议" class="headerlink" title="10.1 建议"></a>10.1 建议</h3><p>命名准则有助于开发同学避免经常查阅资料思考如何去命名字段，可以花更多时间专注研发。使用通用和标准的约定可以帮助开发同学正确猜测到公共属性名称及其含义。 应该使用详细的单词命名，并且不应该使用非通用的缩写词，通用缩写词指的是API范畴内大家公认的(比如Url)。</p>
<h3 id="10-2-格式"><a href="#10-2-格式" class="headerlink" title="10.2 格式"></a>10.2 格式</h3><ul>
<li>缩写<strong>应该</strong>遵循大小写惯例，就像它们是普通单词一样（例如Url）。</li>
<li>所有标识符包括 名称空间（namespaces）、实体类型（entityTypes）、实体集合（entitySets）、属性（properties）、动作（actions）、函数（functions）和枚举值（enumeration）<strong>应该</strong>使用驼峰法（lowerCamelCase）。</li>
<li>HTTP头属性是例外，其<strong>应该</strong>使用Capitalized-Hyphenated-Terms的标准HTTP约定命名。</li>
</ul>
<h3 id="10-3-避免命名"><a href="#10-3-避免命名" class="headerlink" title="10.3 避免命名"></a>10.3 避免命名</h3><p>某些专有词汇的命名应该避免使用，在某些API使用场景里可能会导致冲突。</p>
<p>接口禁止使用以下单词命名：</p>
<ul>
<li>Context</li>
<li>Scope</li>
<li>Resource</li>
</ul>
<h3 id="10-4-复合名称"><a href="#10-4-复合名称" class="headerlink" title="10.4 复合名称"></a>10.4 复合名称</h3><ul>
<li><strong>应该</strong>避免使用诸如’a’，’the’，’of’之类的单词，除非需要有业务必要。<ul>
<li>例如 不应该使用诸如 a User，theAccount，countOfBooks 之类的名称，而应该首选user，account，bookCount。</li>
</ul>
</li>
<li><strong>应该</strong>向属性名添加类型，如果不这样做会导致数据的表示方式不明确。<ul>
<li>向属性名添加类型时，<strong>必须</strong>在末尾添加类型，例如createdDateTime。</li>
</ul>
</li>
</ul>
<h3 id="10-5-标识字段"><a href="#10-5-标识字段" class="headerlink" title="10.5 标识字段"></a>10.5 标识字段</h3><ul>
<li><strong>必须</strong>使用字符串类型定义标识字段。</li>
<li><strong>可以</strong>使用简单的“id”来表示资源主键值。</li>
<li><strong>应该</strong>使用后缀为“Id”的关系名称来表示另一个资源的外键，例如：subscriptionId。</li>
<li>此字段的内容应该是引用资源的规范ID。</li>
</ul>
<h3 id="10-6-时间字段"><a href="#10-6-时间字段" class="headerlink" title="10.6 时间字段"></a>10.6 时间字段</h3><ul>
<li>对于同时需要日期和时间的字段，<strong>必须</strong>使用后缀“DateTime”，例如：createDateTime。</li>
<li>对于只需要日期信息而无需时间的字段，<strong>必须</strong>使用后缀“date”，例如：birthDate。</li>
<li>对于只需要时间信息而无需日期的字段，<strong>必须</strong>使用后缀“time”，例如：startTime。</li>
</ul>
<h3 id="10-7-名称属性"><a href="#10-7-名称属性" class="headerlink" title="10.7 名称属性"></a>10.7 名称属性</h3><ul>
<li>对于通用命名字段，<strong>必须</strong>使用后缀”Name“，例如：agentName。</li>
</ul>
<h3 id="10-8-集合和计数"><a href="#10-8-集合和计数" class="headerlink" title="10.8 集合和计数"></a>10.8 集合和计数</h3><ul>
<li>集合命名必须为复数名词或复数名词短语。</li>
<li><strong>可以</strong>使用简化英语来表示不常用的复数名词。<ul>
<li>例如<strong>可以</strong>用schemas来替代schemata。</li>
</ul>
</li>
<li><strong>必须</strong>使用后缀为“Count”的名词或名词短语来命名资源的计数。</li>
</ul>
<h3 id="10-9-常用字段名称"><a href="#10-9-常用字段名称" class="headerlink" title="10.9 常用字段名称"></a>10.9 常用字段名称</h3><p>如果服务有属性的含义跟下面的命名匹配，则服务必须使用此表中的命名。此表将随着服务添加更常用的术语而更新。所有有相关建议的同学都<strong>可以</strong>一起维护这个表格。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ailpha</td>
</tr>
<tr>
<td>createdDateTime</td>
</tr>
<tr>
<td>contentUrl</td>
</tr>
<tr>
<td>country</td>
</tr>
<tr>
<td>createdBy</td>
</tr>
<tr>
<td>displayName</td>
</tr>
<tr>
<td>errorUrl</td>
</tr>
<tr>
<td>event</td>
</tr>
<tr>
<td>givenName</td>
</tr>
<tr>
<td>jobTitle</td>
</tr>
<tr>
<td>id</td>
</tr>
<tr>
<td>lastModifiedDateTime</td>
</tr>
<tr>
<td>location</td>
</tr>
<tr>
<td>memberOf</td>
</tr>
<tr>
<td>message</td>
</tr>
<tr>
<td>name</td>
</tr>
<tr>
<td>owner</td>
</tr>
<tr>
<td>people</td>
</tr>
<tr>
<td>person</td>
</tr>
<tr>
<td>postalCode</td>
</tr>
<tr>
<td>photo</td>
</tr>
<tr>
<td>properties</td>
</tr>
<tr>
<td>signInName</td>
</tr>
<tr>
<td>tags</td>
</tr>
<tr>
<td>userPrincipalName</td>
</tr>
<tr>
<td>updatedDateTime</td>
</tr>
<tr>
<td>webUrl</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程</category>
        <category>接口</category>
      </categories>
      <tags>
        <tag>restapi</tag>
        <tag>接口规范</tag>
        <tag>代码</tag>
      </tags>
  </entry>
</search>
